soulseer/
â”œâ”€â”€ package.json
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ client/
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ vite.config.js
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ .env
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ main.jsx
â”‚       â”œâ”€â”€ App.jsx
â”‚       â”œâ”€â”€ index.css
â”‚       â”œâ”€â”€ contexts/
â”‚       â”‚   â””â”€â”€ AuthContext.jsx
â”‚       â”œâ”€â”€ hooks/
â”‚       â”‚   â””â”€â”€ useWebRTC.js
â”‚       â”œâ”€â”€ components/
â”‚       â”‚   â”œâ”€â”€ Header.jsx
â”‚       â”‚   â”œâ”€â”€ Footer.jsx
â”‚       â”‚   â”œâ”€â”€ Hero.jsx
â”‚       â”‚   â”œâ”€â”€ ReaderCard.jsx
â”‚       â”‚   â”œâ”€â”€ VideoCall.jsx
â”‚       â”‚   â”œâ”€â”€ ChatBox.jsx
â”‚       â”‚   â”œâ”€â”€ SessionTimer.jsx
â”‚       â”‚   â”œâ”€â”€ BalanceIndicator.jsx
â”‚       â”‚   â””â”€â”€ LoadingSpinner.jsx
â”‚       â”œâ”€â”€ pages/
â”‚       â”‚   â”œâ”€â”€ Home.jsx
â”‚       â”‚   â”œâ”€â”€ About.jsx
â”‚       â”‚   â”œâ”€â”€ Login.jsx
â”‚       â”‚   â”œâ”€â”€ Signup.jsx
â”‚       â”‚   â”œâ”€â”€ ReadingRoom.jsx
â”‚       â”‚   â”œâ”€â”€ Dashboard.jsx
â”‚       â”‚   â”œâ”€â”€ LiveStream.jsx
â”‚       â”‚   â”œâ”€â”€ Shop.jsx
â”‚       â”‚   â”œâ”€â”€ Community.jsx
â”‚       â”‚   â”œâ”€â”€ Messages.jsx
â”‚       â”‚   â”œâ”€â”€ Admin.jsx
â”‚       â”‚   â”œâ”€â”€ Profile.jsx
â”‚       â”‚   â”œâ”€â”€ HelpCenter.jsx
â”‚       â”‚   â””â”€â”€ Policies.jsx
â”‚       â””â”€â”€ utils/
â”‚           â”œâ”€â”€ api.js
â”‚           â””â”€â”€ constants.js
â””â”€â”€ server/
    â”œâ”€â”€ package.json
    â”œâ”€â”€ .env
    â”œâ”€â”€ index.js
    â”œâ”€â”€ config/
    â”‚   â””â”€â”€ database.js
    â”œâ”€â”€ models/
    â”‚   â”œâ”€â”€ User.js
    â”‚   â”œâ”€â”€ Session.js
    â”‚   â”œâ”€â”€ Transaction.js
    â”‚   â””â”€â”€ Message.js
    â”œâ”€â”€ routes/
    â”‚   â”œâ”€â”€ auth.js
    â”‚   â”œâ”€â”€ users.js
    â”‚   â”œâ”€â”€ sessions.js
    â”‚   â”œâ”€â”€ stripe.js
    â”‚   â”œâ”€â”€ messages.js
    â”‚   â””â”€â”€ admin.js
    â”œâ”€â”€ controllers/
    â”‚   â”œâ”€â”€ authController.js
    â”‚   â”œâ”€â”€ sessionController.js
    â”‚   â”œâ”€â”€ stripeController.js
    â”‚   â””â”€â”€ adminController.js
    â”œâ”€â”€ middleware/
    â”‚   â”œâ”€â”€ auth.js
    â”‚   â””â”€â”€ validation.js
    â””â”€â”€ utils/
        â”œâ”€â”€ webrtcSignaling.js
        â””â”€â”€ billing.js

// ROOT PACKAGE.JSON
{
  "name": "soulseer",
  "version": "1.0.0",
  "description": "SoulSeer Psychic Reading Platform",
  "scripts": {
    "dev": "concurrently \"npm run client\" \"npm run server\"",
    "client": "cd client && npm run dev",
    "server": "cd server && npm run dev",
    "build": "cd client && npm run build",
    "install-deps": "npm install && cd client && npm install && cd ../server && npm install"
  },
  "devDependencies": {
    "concurrently": "^7.6.0"
  }
}

// .GITIGNORE
node_modules/
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
npm-debug.log*
yarn-debug.log*
yarn-error.log*
dist/
build/

// CLIENT/PACKAGE.JSON
{
  "name": "soulseer-client",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.8.1",
    "socket.io-client": "^4.7.4",
    "@stripe/stripe-js": "^2.4.0",
    "axios": "^1.6.5"
  },
  "devDependencies": {
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.4.0",
    "vite": "^5.0.8"
  }
}

// CLIENT/VITE.CONFIG.JS
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:4000',
        changeOrigin: true
      }
    }
  }
})

// CLIENT/INDEX.HTML
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SoulSeer - A Community of Gifted Psychics</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Alex+Brush&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

// CLIENT/.ENV
VITE_API_BASE_URL=http://localhost:4000
VITE_STRIPE_PUBLISHABLE_KEY=pk_test_your_stripe_key_here

// CLIENT/SRC/MAIN.JSX
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

// CLIENT/SRC/APP.JSX
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import Header from './components/Header';
import Footer from './components/Footer';
import Home from './pages/Home';
import About from './pages/About';
import Login from './pages/Login';
import Signup from './pages/Signup';
import ReadingRoom from './pages/ReadingRoom';
import Dashboard from './pages/Dashboard';
import LiveStream from './pages/LiveStream';
import Shop from './pages/Shop';
import Community from './pages/Community';
import Messages from './pages/Messages';
import Admin from './pages/Admin';
import Profile from './pages/Profile';
import HelpCenter from './pages/HelpCenter';
import Policies from './pages/Policies';

function App() {
  return (
    <AuthProvider>
      <Router>
        <div className="min-h-screen flex flex-col bg-cosmic">
          <Header />
          <main className="flex-1">
            <Routes>
              <Route path="/" element={<Home />} />
              <Route path="/about" element={<About />} />
              <Route path="/login" element={<Login />} />
              <Route path="/signup" element={<Signup />} />
              <Route path="/reading/:sessionId" element={<ReadingRoom />} />
              <Route path="/dashboard" element={<Dashboard />} />
              <Route path="/live/:streamId?" element={<LiveStream />} />
              <Route path="/shop" element={<Shop />} />
              <Route path="/community" element={<Community />} />
              <Route path="/messages" element={<Messages />} />
              <Route path="/admin" element={<Admin />} />
              <Route path="/profile" element={<Profile />} />
              <Route path="/help" element={<HelpCenter />} />
              <Route path="/policies" element={<Policies />} />
            </Routes>
          </main>
          <Footer />
        </div>
      </Router>
    </AuthProvider>
  );
}

export default App;

// CLIENT/SRC/INDEX.CSS
@import url('https://fonts.googleapis.com/css2?family=Alex+Brush&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap');
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --pink: #FF69B4;
  --gold: #FFD700;
  --black: #000;
  --white: #FFF;
  --bg: #0f0f1a;
  --card-bg: #1a1a2e;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Playfair Display', serif;
  color: var(--white);
  background-color: var(--bg);
}

.bg-cosmic {
  background: url('https://i.postimg.cc/sXdsKGTK/DALL-E-2025-06-06-14-36-29-A-vivid-ethereal-background-image-designed-for-a-psychic-reading-app.webp') no-repeat center center fixed;
  background-size: cover;
  position: relative;
}

.bg-cosmic::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(15, 15, 26, 0.8);
  z-index: -1;
}

.font-alex-brush {
  font-family: 'Alex Brush', cursive;
}

.font-playfair {
  font-family: 'Playfair Display', serif;
}

.text-mystical-pink {
  color: var(--pink);
}

.text-mystical-gold {
  color: var(--gold);
}

.bg-mystical-card {
  background: rgba(26, 26, 46, 0.9);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 105, 180, 0.2);
}

.btn-mystical {
  background: linear-gradient(135deg, var(--pink), #FF1493);
  border: 2px solid var(--gold);
  color: var(--white);
  padding: 12px 24px;
  border-radius: 8px;
  font-family: 'Playfair Display', serif;
  font-weight: 600;
  transition: all 0.3s ease;
  cursor: pointer;
}

.btn-mystical:hover {
  background: linear-gradient(135deg, var(--gold), #FFD700);
  color: var(--black);
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(255, 105, 180, 0.3);
}

.card-mystical {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 24px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(255, 105, 180, 0.2);
  backdrop-filter: blur(10px);
}

.input-mystical {
  background: rgba(26, 26, 46, 0.8);
  border: 2px solid rgba(255, 105, 180, 0.3);
  border-radius: 8px;
  padding: 12px 16px;
  color: var(--white);
  font-family: 'Playfair Display', serif;
  transition: all 0.3s ease;
}

.input-mystical:focus {
  outline: none;
  border-color: var(--pink);
  box-shadow: 0 0 0 3px rgba(255, 105, 180, 0.2);
}

.input-mystical::placeholder {
  color: rgba(255, 255, 255, 0.6);
}

@media (max-width: 768px) {
  .grid-responsive {
    grid-template-columns: 1fr;
  }
}

// CLIENT/SRC/CONTEXTS/AUTHCONTEXT.JSX
import React, { createContext, useContext, useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';

const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();

  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token) {
      axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      fetchUser();
    } else {
      setLoading(false);
    }
  }, []);

  const fetchUser = async () => {
    try {
      const response = await axios.get('/api/auth/me');
      setUser(response.data.user);
    } catch (error) {
      localStorage.removeItem('token');
      delete axios.defaults.headers.common['Authorization'];
    } finally {
      setLoading(false);
    }
  };

  const login = async (email, password) => {
    try {
      const response = await axios.post('/api/auth/login', { email, password });
      const { token, user } = response.data;
      
      localStorage.setItem('token', token);
      axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      setUser(user);
      
      navigate('/dashboard');
      return { success: true };
    } catch (error) {
      return { success: false, error: error.response?.data?.message || 'Login failed' };
    }
  };

  const signup = async (email, password, role = 'client') => {
    try {
      const response = await axios.post('/api/auth/signup', { email, password, role });
      const { token, user } = response.data;
      
      localStorage.setItem('token', token);
      axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      setUser(user);
      
      navigate('/dashboard');
      return { success: true };
    } catch (error) {
      return { success: false, error: error.response?.data?.message || 'Signup failed' };
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    delete axios.defaults.headers.common['Authorization'];
    setUser(null);
    navigate('/');
  };

  const value = {
    user,
    login,
    signup,
    logout,
    loading
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

// CLIENT/SRC/HOOKS/USEWEBRTC.JS
import { useEffect, useRef, useState } from 'react';
import { io } from 'socket.io-client';
import axios from 'axios';

export const useWebRTC = (sessionId, userRole, readerRate) => {
  const [localStream, setLocalStream] = useState(null);
  const [remoteStream, setRemoteStream] = useState(null);
  const [messages, setMessages] = useState([]);
  const [connectionStatus, setConnectionStatus] = useState('connecting');
  const [sessionTime, setSessionTime] = useState(0);
  const [balance, setBalance] = useState(0);
  
  const socketRef = useRef();
  const peerConnectionRef = useRef();
  const dataChannelRef = useRef();
  const billingIntervalRef = useRef();
  const sessionTimerRef = useRef();

  useEffect(() => {
    initializeWebRTC();
    return cleanup;
  }, [sessionId]);

  const initializeWebRTC = async () => {
    try {
      // Initialize Socket.IO
      socketRef.current = io('http://localhost:4000');
      
      // Get user media
      const stream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
      });
      setLocalStream(stream);
      
      // Create peer connection
      peerConnectionRef.current = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      });
      
      // Add local stream
      stream.getTracks().forEach(track => {
        peerConnectionRef.current.addTrack(track, stream);
      });
      
      // Handle remote stream
      peerConnectionRef.current.ontrack = (event) => {
        setRemoteStream(event.streams[0]);
      };
      
      // Setup data channel for chat
      if (userRole === 'client') {
        dataChannelRef.current = peerConnectionRef.current.createDataChannel('chat');
        setupDataChannel();
      } else {
        peerConnectionRef.current.ondatachannel = (event) => {
          dataChannelRef.current = event.channel;
          setupDataChannel();
        };
      }
      
      // Setup signaling
      setupSignaling();
      
      // Start session if client
      if (userRole === 'client') {
        startSession();
      }
      
    } catch (error) {
      console.error('WebRTC initialization failed:', error);
      setConnectionStatus('failed');
    }
  };

  const setupSignaling = () => {
    const socket = socketRef.current;
    const pc = peerConnectionRef.current;
    
    socket.emit('join-session', sessionId);
    
    // ICE candidate handling
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        socket.emit('ice-candidate', {
          sessionId,
          candidate: event.candidate
        });
      }
    };
    
    socket.on('ice-candidate', (candidate) => {
      pc.addIceCandidate(new RTCIceCandidate(candidate));
    });
    
    // Offer/Answer handling
    socket.on('offer', async (offer) => {
      await pc.setRemoteDescription(offer);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      socket.emit('answer', { sessionId, answer });
    });
    
    socket.on('answer', async (answer) => {
      await pc.setRemoteDescription(answer);
      setConnectionStatus('connected');
      if (userRole === 'client') {
        startBilling();
      }
    });
    
    socket.on('session-ended', () => {
      endSession();
    });
  };

  const setupDataChannel = () => {
    const dc = dataChannelRef.current;
    
    dc.onopen = () => {
      console.log('Data channel opened');
    };
    
    dc.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
    };
  };

  const startSession = async () => {
    try {
      const pc = peerConnectionRef.current;
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socketRef.current.emit('offer', { sessionId, offer });
      
      // Start session timer
      sessionTimerRef.current = setInterval(() => {
        setSessionTime(prev => prev + 1);
      }, 1000);
      
    } catch (error) {
      console.error('Failed to start session:', error);
    }
  };

  const startBilling = () => {
    // Charge every minute
    billingIntervalRef.current = setInterval(async () => {
      try {
        const response = await axios.post('/api/sessions/charge', {
          sessionId,
          amount: Math.round(readerRate * 100) // Convert to cents
        });
        
        setBalance(response.data.balance);
        
        if (response.data.balance < readerRate) {
          endSession();
        }
      } catch (error) {
        console.error('Billing failed:', error);
        endSession();
      }
    }, 60000); // 1 minute
  };

  const sendMessage = (text) => {
    if (dataChannelRef.current && dataChannelRef.current.readyState === 'open') {
      const message = {
        text,
        sender: userRole,
        timestamp: Date.now()
      };
      dataChannelRef.current.send(JSON.stringify(message));
      setMessages(prev => [...prev, message]);
    }
  };

  const toggleVideo = () => {
    if (localStream) {
      const videoTrack = localStream.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled;
      }
    }
  };

  const toggleAudio = () => {
    if (localStream) {
      const audioTrack = localStream.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
      }
    }
  };

  const endSession = async () => {
    try {
      // Notify server
      await axios.post(`/api/sessions/${sessionId}/end`);
      
      // Notify other peer
      socketRef.current.emit('end-session', sessionId);
      
      setConnectionStatus('ended');
      cleanup();
    } catch (error) {
      console.error('Failed to end session:', error);
    }
  };

  const cleanup = () => {
    // Stop local stream
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
    }
    
    // Close peer connection
    if (peerConnectionRef.current) {
      peerConnectionRef.current.close();
    }
    
    // Disconnect socket
    if (socketRef.current) {
      socketRef.current.disconnect();
    }
    
    // Clear intervals
    if (billingIntervalRef.current) {
      clearInterval(billingIntervalRef.current);
    }
    
    if (sessionTimerRef.current) {
      clearInterval(sessionTimerRef.current);
    }
  };

  return {
    localStream,
    remoteStream,
    messages,
    connectionStatus,
    sessionTime,
    balance,
    sendMessage,
    toggleVideo,
    toggleAudio,
    endSession
  };
};

// CLIENT/SRC/COMPONENTS/HEADER.JSX
import React, { useState } from 'react';
import { Link, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

const Header = () => {
  const { user, logout } = useAuth();
  const location = useLocation();
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);

  const isActive = (path) => location.pathname === path;

  const navigation = [
    { name: 'Home', path: '/' },
    { name: 'About', path: '/about' },
    { name: 'Readings', path: '/dashboard' },
    { name: 'Live', path: '/live' },
    { name: 'Shop', path: '/shop' },
    { name: 'Community', path: '/community' },
    { name: 'Messages', path: '/messages' }
  ];

  return (
    <header className="bg-black bg-opacity-80 backdrop-filter backdrop-blur-lg border-b border-pink-500 border-opacity-20 sticky top-0 z-50">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center h-16">
          {/* Logo */}
          <Link to="/" className="flex items-center">
            <h1 className="font-alex-brush text-4xl text-mystical-pink">
              SoulSeer
            </h1>
          </Link>

          {/* Desktop Navigation */}
          <nav className="hidden md:flex space-x-8">
            {navigation.map((item) => (
              <Link
                key={item.name}
                to={item.path}
                className={`font-playfair transition-colors duration-200 ${
                  isActive(item.path)
                    ? 'text-mystical-pink'
                    : 'text-white hover:text-mystical-pink'
                }`}
              >
                {item.name}
              </Link>
            ))}
          </nav>

          {/* Auth Buttons / User Menu */}
          <div className="hidden md:flex items-center space-x-4">
            {user ? (
              <div className="flex items-center space-x-4">
                <Link
                  to="/dashboard"
                  className="font-playfair text-white hover:text-mystical-pink transition-colors"
                >
                  Dashboard
                </Link>
                <Link
                  to="/profile"
                  className="font-playfair text-white hover:text-mystical-pink transition-colors"
                >
                  Profile
                </Link>
                {user.role === 'admin' && (
                  <Link
                    to="/admin"
                    className="font-playfair text-mystical-gold hover:text-yellow-300 transition-colors"
                  >
                    Admin
                  </Link>
                )}
                <button
                  onClick={logout}
                  className="btn-mystical"
                >
                  Logout
                </button>
              </div>
            ) : (
              <div className="flex items-center space-x-4">
                <Link
                  to="/login"
                  className="font-playfair text-white hover:text-mystical-pink transition-colors"
                >
                  Login
                </Link>
                <Link
                  to="/signup"
                  className="btn-mystical"
                >
                  Sign Up
                </Link>
              </div>
            )}
          </div>

          {/* Mobile menu button */}
          <div className="md:hidden">
            <button
              onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
              className="text-white hover:text-mystical-pink transition-colors"
            >
              <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
              </svg>
            </button>
          </div>
        </div>
      </div>

      {/* Mobile Navigation */}
      {isMobileMenuOpen && (
        <div className="md:hidden bg-black bg-opacity-90 border-t border-pink-500 border-opacity-20">
          <div className="px-2 pt-2 pb-3 space-y-1">
            {navigation.map((item) => (
              <Link
                key={item.name}
                to={item.path}
                className={`block px-3 py-2 font-playfair ${
                  isActive(item.path)
                    ? 'text-mystical-pink'
                    : 'text-white hover:text-mystical-pink'
                }`}
                onClick={() => setIsMobileMenuOpen(false)}
              >
                {item.name}
              </Link>
            ))}
            {user ? (
              <>
                <Link
                  to="/dashboard"
                  className="block px-3 py-2 font-playfair text-white hover:text-mystical-pink"
                  onClick={() => setIsMobileMenuOpen(false)}
                >
                  Dashboard
                </Link>
                <Link
                  to="/profile"
                  className="block px-3 py-2 font-playfair text-white hover:text-mystical-pink"
                  onClick={() => setIsMobileMenuOpen(false)}
                >
                  Profile
                </Link>
                {user.role === 'admin' && (
                  <Link
                    to="/admin"
                    className="block px-3 py-2 font-playfair text-mystical-gold hover:text-yellow-300"
                    onClick={() => setIsMobileMenuOpen(false)}
                  >
                    Admin
                  </Link>
                )}
                <button
                  onClick={() => {
                    logout();
                    setIsMobileMenuOpen(false);
                  }}
                  className="block w-full text-left px-3 py-2 font-playfair text-white hover:text-mystical-pink"
                >
                  Logout
                </button>
              </>
            ) : (
              <>
                <Link
                  to="/login"
                  className="block px-3 py-2 font-playfair text-white hover:text-mystical-pink"
                  onClick={() => setIsMobileMenuOpen(false)}
                >
                  Login
                </Link>
                <Link
                  to="/signup"
                  className="block px-3 py-2 font-playfair text-white hover:text-mystical-pink"
                  onClick={() => setIsMobileMenuOpen(false)}
                >
                  Sign Up
                </Link>
              </>
            )}
          </div>
        </div>
      )}
    </header>
  );
};

export default Header;

// CLIENT/SRC/COMPONENTS/FOOTER.JSX
import React from 'react';
import { Link } from 'react-router-dom';

const Footer = () => {
  return (
    <footer className="bg-black bg-opacity-90 border-t border-pink-500 border-opacity-20 mt-auto">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
          {/* Brand */}
          <div className="col-span-1 md:col-span-2">
            <h3 className="font-alex-brush text-3xl text-mystical-pink mb-4">
              SoulSeer
            </h3>
            <p className="font-playfair text-gray-300 mb-4">
              A Community of Gifted Psychics
            </p>
            <p className="font-playfair text-gray-400 text-sm">
              Providing ethical, compassionate, and judgment-free spiritual guidance.
            </p>
          </div>

          {/* Quick Links */}
          <div>
            <h4 className="font-playfair text-white font-semibold mb-4">Quick Links</h4>
            <ul className="space-y-2">
              <li>
                <Link to="/about" className="font-playfair text-gray-300 hover:text-mystical-pink transition-colors">
                  About Us
                </Link>
              </li>
              <li>
                <Link to="/help" className="font-playfair text-gray-300 hover:text-mystical-pink transition-colors">
                  Help Center
                </Link>
              </li>
              <li>
                <Link to="/policies" className="font-playfair text-gray-300 hover:text-mystical-pink transition-colors">
                  Terms & Privacy
                </Link>
              </li>
            </ul>
          </div>

          {/* Contact */}
          <div>
            <h4 className="font-playfair text-white font-semibold mb-4">Support</h4>
            <ul className="space-y-2">
              <li>
                <a href="mailto:support@soulseer.com" className="font-playfair text-gray-300 hover:text-mystical-pink transition-colors">
                  support@soulseer.com
                </a>
              </li>
              <li>
                <span className="font-playfair text-gray-300">
                  24/7 Customer Support
                </span>
              </li>
            </ul>
          </div>
        </div>

        <div className="border-t border-pink-500 border-opacity-20 mt-8 pt-8 text-center">
          <p className="font-playfair text-gray-400 text-sm">
            Â© 2025 SoulSeer. All rights reserved.
          </p>
        </div>
      </div>
    </footer>
  );
};

export default Footer;

// CLIENT/SRC/COMPONENTS/HERO.JSX
import React from 'react';

const Hero = () => {
  return (
    <div className="relative py-16">
      <div className="max-w-4xl mx-auto text-center px-4">
        <img 
          src="https://i.postimg.cc/tRLSgCPb/HERO-IMAGE-1.jpg"
          alt="SoulSeer Hero"
          className="w-full max-w-3xl mx-auto rounded-lg shadow-2xl mb-8"
        />
        <p className="font-playfair text-2xl text-white mb-8">
          A Community of Gifted Psychics
        </p>
        <p className="font-playfair text-lg text-gray-300 mb-8 max-w-2xl mx-auto">
          Connect with authentic spiritual readers for guidance, clarity, and healing on your journey.
        </p>
        <div className="flex flex-col sm:flex-row gap-4 justify-center">
          <button className="btn-mystical">
            Find Your Reader
          </button>
          <button className="btn-mystical">
            Join Live Streams
          </button>
        </div>
      </div>
    </div>
  );
};

export default Hero;

// CLIENT/SRC/COMPONENTS/READERCARD.JSX
import React from 'react';

const ReaderCard = ({ reader, onConnect }) => {
  return (
    <div className="card-mystical hover:transform hover:scale-105 transition-all duration-300">
      <div className="flex items-center space-x-4 mb-4">
        <img
          src={reader.avatar || '/default-avatar.png'}
          alt={reader.name}
          className="w-16 h-16 rounded-full border-2 border-mystical-pink"
        />
        <div>
          <h3 className="font-playfair text-xl text-white font-semibold">
            {reader.name}
          </h3>
          <p className="font-playfair text-mystical-pink">
            {reader.specialty}
          </p>
        </div>
      </div>
      
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center space-x-2">
          <span className="font-playfair text-mystical-gold font-semibold">
            ${reader.rate}/min
          </span>
          <div className="flex items-center">
            <span className="text-yellow-400">â˜…</span>
            <span className="font-playfair text-white ml-1">
              {reader.rating}
            </span>
          </div>
        </div>
        <div className={`px-3 py-1 rounded-full text-sm font-playfair ${
          reader.isOnline 
            ? 'bg-green-500 bg-opacity-20 text-green-400 border border-green-500' 
            : 'bg-gray-500 bg-opacity-20 text-gray-400 border border-gray-500'
        }`}>
          {reader.isOnline ? 'Online' : 'Offline'}
        </div>
      </div>
      
      <p className="font-playfair text-gray-300 text-sm mb-4">
        {reader.description || 'Experienced spiritual advisor ready to guide you.'}
      </p>
      
      <div className="flex space-x-2">
        <button 
          className="btn-mystical flex-1"
          onClick={() => onConnect(reader.id, 'video')}
          disabled={!reader.isOnline}
        >
          Video Call
        </button>
        <button 
          className="btn-mystical flex-1"
          onClick={() => onConnect(reader.id, 'audio')}
          disabled={!reader.isOnline}
        >
          Audio Call
        </button>
        <button 
          className="btn-mystical flex-1"
          onClick={() => onConnect(reader.id, 'chat')}
          disabled={!reader.isOnline}
        >
          Chat
        </button>
      </div>
    </div>
  );
};

export default ReaderCard;

// CLIENT/SRC/COMPONENTS/VIDEOCALL.JSX
import React, { useRef, useEffect } from 'react';

const VideoCall = ({ localStream, remoteStream, onToggleVideo, onToggleAudio, onEndCall }) => {
  const localVideoRef = useRef();
  const remoteVideoRef = useRef();

  useEffect(() => {
    if (localVideoRef.current && localStream) {
      localVideoRef.current.srcObject = localStream;
    }
  }, [localStream]);

  useEffect(() => {
    if (remoteVideoRef.current && remoteStream) {
      remoteVideoRef.current.srcObject = remoteStream;
    }
  }, [remoteStream]);

  return (
    <div className="relative w-full h-96 bg-black rounded-lg overflow-hidden">
      {/* Remote Video */}
      <video
        ref={remoteVideoRef}
        autoPlay
        playsInline
        className="w-full h-full object-cover"
      />
      
      {/* Local Video */}
      <video
        ref={localVideoRef}
        autoPlay
        playsInline
        muted
        className="absolute top-4 right-4 w-32 h-24 object-cover rounded-lg border-2 border-mystical-pink"
      />
      
      {/* Controls */}
      <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex space-x-4">
        <button
          onClick={onToggleVideo}
          className="p-3 rounded-full bg-gray-800 text-white hover:bg-gray-700 transition-colors"
        >
          ðŸ“¹
        </button>
        <button
          onClick={onToggleAudio}
          className="p-3 rounded-full bg-gray-800 text-white hover:bg-gray-700 transition-colors"
        >
          ðŸŽ¤
        </button>
        <button
          onClick={onEndCall}
          className="p-3 rounded-full bg-red-600 text-white hover:bg-red-700 transition-colors"
        >
          ðŸ“ž
        </button>
      </div>
    </div>
  );
};

export default VideoCall;

// CLIENT/SRC/COMPONENTS/CHATBOX.JSX
import React, { useState, useRef, useEffect } from 'react';

const ChatBox = ({ messages, onSendMessage, connectionStatus }) => {
  const [newMessage, setNewMessage] = useState('');
  const messagesEndRef = useRef(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (newMessage.trim() && connectionStatus === 'connected') {
      onSendMessage(newMessage.trim());
      setNewMessage('');
    }
  };

  return (
    <div className="card-mystical h-96 flex flex-col">
      <h3 className="font-playfair text-xl text-mystical-pink mb-4">Chat</h3>
      
      {/* Messages */}
      <div className="flex-1 overflow-y-auto mb-4 space-y-2">
        {messages.map((message, index) => (
          <div
            key={index}
            className={`p-2 rounded-lg max-w-xs ${
              message.sender === 'client' 
                ? 'bg-mystical-pink text-white ml-auto' 
                : 'bg-gray-700 text-white'
            }`}
          >
            <p className="font-playfair text-sm">{message.text}</p>
            <span className="text-xs opacity-70">
              {new Date(message.timestamp).toLocaleTimeString()}
            </span>
          </div>
        ))}
        <div ref={messagesEndRef} />
      </div>
      
      {/* Input */}
      <form onSubmit={handleSubmit} className="flex space-x-2">
        <input
          type="text"
          value={newMessage}
          onChange={(e) => setNewMessage(e.target.value)}
          placeholder="Type your message..."
          className="input-mystical flex-1"
          disabled={connectionStatus !== 'connected'}
        />
        <button
          type="submit"
          className="btn-mystical"
          disabled={connectionStatus !== 'connected' || !newMessage.trim()}
        >
          Send
        </button>
      </form>
      
      {connectionStatus !== 'connected' && (
        <p className="font-playfair text-yellow-400 text-sm mt-2">
          {connectionStatus === 'connecting' ? 'Connecting...' : 'Disconnected'}
        </p>
      )}
    </div>
  );
};

export default ChatBox;

// CLIENT/SRC/COMPONENTS/SESSIONTIMER.JSX
import React from 'react';

const SessionTimer = ({ sessionTime, readerRate }) => {
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  const totalCost = (sessionTime / 60) * readerRate;

  return (
    <div className="bg-gray-800 bg-opacity-50 rounded-lg p-4 mb-4">
      <div className="text-center">
        <div className="font-alex-brush text-3xl text-mystical-pink mb-2">
          {formatTime(sessionTime)}
        </div>
        <div className="font-playfair text-white">
          Session Time
        </div>
        <div className="font-playfair text-mystical-gold text-lg mt-2">
          ${totalCost.toFixed(2)} total
        </div>
        <div className="font-playfair text-gray-300 text-sm">
          ${readerRate}/min
        </div>
      </div>
    </div>
  );
};

export default SessionTimer;

// CLIENT/SRC/COMPONENTS/BALANCEINDICATOR.JSX
import React from 'react';

const BalanceIndicator = ({ balance, readerRate }) => {
  const minutesRemaining = Math.floor(balance / readerRate);
  const isLowBalance = minutesRemaining < 5;

  return (
    <div className={`p-4 rounded-lg border-2 ${
      isLowBalance 
        ? 'bg-red-900 bg-opacity-30 border-red-500' 
        : 'bg-green-900 bg-opacity-30 border-green-500'
    }`}>
      <div className="text-center">
        <div className="font-playfair text-2xl font-bold text-white mb-1">
          ${balance.toFixed(2)}
        </div>
        <div className="font-playfair text-sm text-gray-300 mb-2">
          Account Balance
        </div>
        <div className={`font-playfair text-sm ${isLowBalance ? 'text-red-400' : 'text-green-400'}`}>
          ~{minutesRemaining} minutes remaining
        </div>
        {isLowBalance && (
          <div className="mt-2">
            <button className="btn-mystical text-xs px-3 py-1">
              Add Funds
            </button>
          </div>
        )}
      </div>
    </div>
  );
};

export default BalanceIndicator;

// CLIENT/SRC/COMPONENTS/LOADINGSPINNER.JSX
import React from 'react';

const LoadingSpinner = ({ size = 'md', text = 'Loading...' }) => {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12'
  };

  return (
    <div className="flex flex-col items-center justify-center p-8">
      <div className={`${sizeClasses[size]} border-2 border-mystical-pink border-t-transparent rounded-full animate-spin mb-2`}></div>
      <p className="font-playfair text-white text-sm">{text}</p>
    </div>
  );
};

export default LoadingSpinner;

// CLIENT/SRC/PAGES/HOME.JSX
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import Hero from '../components/Hero';
import ReaderCard from '../components/ReaderCard';
import LoadingSpinner from '../components/LoadingSpinner';
import axios from 'axios';

const Home = () => {
  const [readers, setReaders] = useState([]);
  const [liveStreams, setLiveStreams] = useState([]);
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();

  useEffect(() => {
    fetchHomeData();
  }, []);

  const fetchHomeData = async () => {
    try {
      const [readersRes, streamsRes] = await Promise.all([
        axios.get('/api/users/readers'),
        axios.get('/api/streams/live')
      ]);
      
      setReaders(readersRes.data);
      setLiveStreams(streamsRes.data);
    } catch (error) {
      console.error('Failed to fetch home data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleConnectReader = async (readerId, sessionType) => {
    try {
      const response = await axios.post('/api/sessions/request', {
        readerId,
        sessionType
      });
      
      navigate(`/reading/${response.data.sessionId}`);
    } catch (error) {
      console.error('Failed to connect to reader:', error);
      alert('Failed to connect to reader. Please try again.');
    }
  };

  if (loading) {
    return <LoadingSpinner text="Loading readers..." />;
  }

  return (
    <div className="min-h-screen">
      <Hero />
      
      {/* Online Readers */}
      <section className="py-16">
        <div className="max-w-7xl mx-auto px-4">
          <h2 className="font-alex-brush text-4xl text-mystical-pink text-center mb-12">
            Featured Readers Online Now
          </h2>
          
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
            {readers.filter(reader => reader.isOnline).map((reader) => (
              <ReaderCard
                key={reader.id}
                reader={reader}
                onConnect={handleConnectReader}
              />
            ))}
          </div>
          
          {readers.filter(reader => reader.isOnline).length === 0 && (
            <div className="text-center py-12">
              <p className="font-playfair text-gray-300 text-lg">
                No readers are currently online. Check back soon!
              </p>
            </div>
          )}
        </div>
      </section>
      
      {/* Live Streams */}
      <section className="py-16 bg-black bg-opacity-30">
        <div className="max-w-7xl mx-auto px-4">
          <h2 className="font-alex-brush text-4xl text-mystical-pink text-center mb-12">
            Live Streams
          </h2>
          
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
            {liveStreams.map((stream) => (
              <div key={stream.id} className="card-mystical cursor-pointer hover:transform hover:scale-105 transition-all duration-300"
                   onClick={() => navigate(`/live/${stream.id}`)}>
                <div className="flex items-center justify-between mb-4">
                  <h3 className="font-playfair text-xl text-white font-semibold">
                    {stream.title}
                  </h3>
                  <div className="flex items-center space-x-2">
                    <div className="w-3 h-3 bg-red-500 rounded-full animate-pulse"></div>
                    <span className="font-playfair text-red-400 text-sm">LIVE</span>
                  </div>
                </div>
                
                <p className="font-playfair text-gray-300 mb-4">
                  {stream.readerName}
                </p>
                
                <div className="flex items-center justify-between">
                  <span className="font-playfair text-mystical-gold">
                    {stream.viewers} viewers
                  </span>
                  <button className="btn-mystical">
                    Join Stream
                  </button>
                </div>
              </div>
            ))}
          </div>
          
          {liveStreams.length === 0 && (
            <div className="text-center py-12">
              <p className="font-playfair text-gray-300 text-lg">
                No live streams at the moment. Check back soon!
              </p>
            </div>
          )}
        </div>
      </section>
    </div>
  );
};

export default Home;

// CLIENT/SRC/PAGES/ABOUT.JSX
import React from 'react';

const About = () => {
  return (
    <div className="min-h-screen py-16">
      <div className="max-w-4xl mx-auto px-4">
        <div className="text-center mb-16">
          <h1 className="font-alex-brush text-6xl text-mystical-pink mb-8">
            About SoulSeer
          </h1>
        </div>
        
        <div className="card-mystical mb-12">
          <div className="prose prose-lg max-w-none">
            <p className="font-playfair text-white text-lg leading-relaxed mb-6">
              At SoulSeer, we are dedicated to providing ethical, compassionate, and judgment-free spiritual guidance. Our mission is twofold: to offer clients genuine, heart-centered readings and to uphold fair, ethical standards for our readers.
            </p>
            
            <p className="font-playfair text-white text-lg leading-relaxed mb-6">
              Founded by psychic medium Emilynn, SoulSeer was created as a response to the corporate greed that dominates many psychic platforms. Unlike other apps, our readers keep the majority of what they earn and play an active role in shaping the platform.
            </p>
            
            <p className="font-playfair text-white text-lg leading-relaxed mb-8">
              SoulSeer is more than just an appâ€”it's a soul tribe. A community of gifted psychics united by our life's calling: to guide, heal, and empower those who seek clarity on their journey.
            </p>
          </div>
        </div>
        
        <div className="text-center mb-12">
          <img 
            src="https://i.postimg.cc/s2ds9RtC/FOUNDER.jpg"
            alt="Founder: Emilynn"
            className="w-64 h-64 object-cover rounded-full mx-auto border-4 border-mystical-pink shadow-2xl mb-6"
          />
          <h2 className="font-alex-brush text-4xl text-mystical-pink mb-4">
            Meet Our Founder
          </h2>
          <h3 className="font-playfair text-2xl text-white mb-4">
            Emilynn - Psychic Medium
          </h3>
          <p className="font-playfair text-gray-300 text-lg max-w-2xl mx-auto">
            With over 15 years of experience in spiritual guidance, Emilynn founded SoulSeer to create a platform that truly serves both clients and readers with integrity and fairness.
          </p>
        </div>
        
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8 mb-12">
          <div className="card-mystical text-center">
            <h3 className="font-alex-brush text-3xl text-mystical-pink mb-4">
              Ethical Standards
            </h3>
            <p className="font-playfair text-white">
              We maintain the highest ethical standards in all our spiritual services and reader interactions.
            </p>
          </div>
          
          <div className="card-mystical text-center">
            <h3 className="font-alex-brush text-3xl text-mystical-pink mb-4">
              Fair Revenue
            </h3>
            <p className="font-playfair text-white">
              Our readers keep 70% of their earnings, ensuring they are fairly compensated for their gifts.
            </p>
          </div>
          
          <div className="card-mystical text-center">
            <h3 className="font-alex-brush text-3xl text-mystical-pink mb-4">
              Community
            </h3>
            <p className="font-playfair text-white">
              We foster a supportive community where both clients and readers can grow and connect.
            </p>
          </div>
        </div>
        
        <div className="text-center">
          <button className="btn-mystical mr-4">
            Find Your Reader
          </button>
          <button className="btn-mystical">
            Join Our Community
          </button>
        </div>
      </div>
    </div>
  );
};

export default About;

// CLIENT/SRC/PAGES/LOGIN.JSX
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import LoadingSpinner from '../components/LoadingSpinner';

const Login = () => {
  const [formData, setFormData] = useState({
    email: '',
    password: ''
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  
  const { login } = useAuth();

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    const result = await login(formData.email, formData.password);
    
    if (!result.success) {
      setError(result.error);
    }
    
    setLoading(false);
  };

  if (loading) {
    return <LoadingSpinner text="Signing you in..." />;
  }

  return (
    <div className="min-h-screen flex items-center justify-center py-12">
      <div className="max-w-md w-full mx-4">
        <div className="card-mystical">
          <div className="text-center mb-8">
            <h2 className="font-alex-brush text-4xl text-mystical-pink mb-2">
              Welcome Back
            </h2>
            <p className="font-playfair text-gray-300">
              Sign in to your SoulSeer account
            </p>
          </div>

          {error && (
            <div className="bg-red-900 bg-opacity-30 border border-red-500 rounded-lg p-4 mb-6">
              <p className="font-playfair text-red-400 text-sm">{error}</p>
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-6">
            <div>
              <label className="font-playfair text-white text-sm font-medium mb-2 block">
                Email Address
              </label>
              <input
                type="email"
                name="email"
                value={formData.email}
                onChange={handleChange}
                className="input-mystical w-full"
                placeholder="Enter your email"
                required
              />
            </div>

            <div>
              <label className="font-playfair text-white text-sm font-medium mb-2 block">
                Password
              </label>
              <input
                type="password"
                name="password"
                value={formData.password}
                onChange={handleChange}
                className="input-mystical w-full"
                placeholder="Enter your password"
                required
              />
            </div>

            <button
              type="submit"
              className="btn-mystical w-full"
              disabled={loading}
            >
              Sign In
            </button>
          </form>

          <div className="mt-6 text-center">
            <p className="font-playfair text-gray-300">
              Don't have an account?{' '}
              <Link to="/signup" className="text-mystical-pink hover:text-pink-300 transition-colors">
                Sign up here
              </Link>
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Login;

// CLIENT/SRC/PAGES/SIGNUP.JSX
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import LoadingSpinner from '../components/LoadingSpinner';

const Signup = () => {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  
  const { signup } = useAuth();

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    if (formData.password !== formData.confirmPassword) {
      setError('Passwords do not match');
      setLoading(false);
      return;
    }

    if (formData.password.length < 6) {
      setError('Password must be at least 6 characters long');
      setLoading(false);
      return;
    }

    const result = await signup(formData.email, formData.password);
    
    if (!result.success) {
      setError(result.error);
    }
    
    setLoading(false);
  };

  if (loading) {
    return <LoadingSpinner text="Creating your account..." />;
  }

  return (
    <div className="min-h-screen flex items-center justify-center py-12">
      <div className="max-w-md w-full mx-4">
        <div className="card-mystical">
          <div className="text-center mb-8">
            <h2 className="font-alex-brush text-4xl text-mystical-pink mb-2">
              Join SoulSeer
            </h2>
            <p className="font-playfair text-gray-300">
              Create your account to connect with gifted psychics
            </p>
          </div>

          {error && (
            <div className="bg-red-900 bg-opacity-30 border border-red-500 rounded-lg p-4 mb-6">
              <p className="font-playfair text-red-400 text-sm">{error}</p>
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-6">
            <div>
              <label className="font-playfair text-white text-sm font-medium mb-2 block">
                Email Address
              </label>
              <input
                type="email"
                name="email"
                value={formData.email}
                onChange={handleChange}
                className="input-mystical w-full"
                placeholder="Enter your email"
                required
              />
            </div>

            <div>
              <label className="font-playfair text-white text-sm font-medium mb-2 block">
                Password
              </label>
              <input
                type="password"
                name="password"
                value={formData.password}
                onChange={handleChange}
                className="input-mystical w-full"
                placeholder="Create a password"
                required
              />
            </div>

            <div>
              <label className="font-playfair text-white text-sm font-medium mb-2 block">
                Confirm Password
              </label>
              <input
                type="password"
                name="confirmPassword"
                value={formData.confirmPassword}
                onChange={handleChange}
                className="input-mystical w-full"
                placeholder="Confirm your password"
                required
              />
            </div>

            <button
              type="submit"
              className="btn-mystical w-full"
              disabled={loading}
            >
              Create Account
            </button>
          </form>

          <div className="mt-6 text-center">
            <p className="font-playfair text-gray-300">
              Already have an account?{' '}
              <Link to="/login" className="text-mystical-pink hover:text-pink-300 transition-colors">
                Sign in here
              </Link>
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Signup;

// CLIENT/SRC/PAGES/READINGROOM.JSX
import React from 'react';
import { useParams } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useWebRTC } from '../hooks/useWebRTC';
import VideoCall from '../components/VideoCall';
import ChatBox from '../components/ChatBox';
import SessionTimer from '../components/SessionTimer';
import BalanceIndicator from '../components/BalanceIndicator';
import LoadingSpinner from '../components/LoadingSpinner';

const ReadingRoom = () => {
  const { sessionId } = useParams();
  const { user } = useAuth();
  
  const {
    localStream,
    remoteStream,
    messages,
    connectionStatus,
    sessionTime,
    balance,
    sendMessage,
    toggleVideo,
    toggleAudio,
    endSession
  } = useWebRTC(sessionId, user?.role, 3.99); // Default rate

  if (connectionStatus === 'connecting') {
    return <LoadingSpinner text="Connecting to your reading..." />;
  }

  if (connectionStatus === 'failed') {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="card-mystical text-center max-w-md">
          <h2 className="font-alex-brush text-3xl text-mystical-pink mb-4">
            Connection Failed
          </h2>
          <p className="font-playfair text-white mb-6">
            We couldn't establish a connection. Please try again.
          </p>
          <button 
            className="btn-mystical"
            onClick={() => window.location.reload()}
          >
            Try Again
          </button>
        </div>
      </div>
    );
  }

  if (connectionStatus === 'ended') {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="card-mystical text-center max-w-md">
          <h2 className="font-alex-brush text-3xl text-mystical-pink mb-4">
            Session Ended
          </h2>
          <p className="font-playfair text-white mb-6">
            Thank you for using SoulSeer. We hope your reading was helpful.
          </p>
          <button 
            className="btn-mystical"
            onClick={() => window.location.href = '/dashboard'}
          >
            Return to Dashboard
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen py-8">
      <div className="max-w-7xl mx-auto px-4">
        <div className="grid grid-cols-1 lg:grid-cols-4 gap-8">
          {/* Video Call Area */}
          <div className="lg:col-span-3">
            <div className="card-mystical">
              <div className="mb-4 flex items-center justify-between">
                <h2 className="font-alex-brush text-3xl text-mystical-pink">
                  Live Reading Session
                </h2>
                <div className={`px-3 py-1 rounded-full text-sm font-playfair ${
                  connectionStatus === 'connected' 
                    ? 'bg-green-500 bg-opacity-20 text-green-400 border border-green-500' 
                    : 'bg-yellow-500 bg-opacity-20 text-yellow-400 border border-yellow-500'
                }`}>
                  {connectionStatus === 'connected' ? 'Connected' : 'Connecting...'}
                </div>
              </div>
              
              <VideoCall
                localStream={localStream}
                remoteStream={remoteStream}
                onToggleVideo={toggleVideo}
                onToggleAudio={toggleAudio}
                onEndCall={endSession}
              />
            </div>
          </div>

          {/* Sidebar */}
          <div className="space-y-6">
            {/* Session Timer */}
            <SessionTimer 
              sessionTime={sessionTime}
              readerRate={3.99}
            />
            
            {/* Balance Indicator */}
            {user?.role === 'client' && (
              <BalanceIndicator 
                balance={balance}
                readerRate={3.99}
              />
            )}
            
            {/* Chat */}
            <ChatBox
              messages={messages}
              onSendMessage={sendMessage}
              connectionStatus={connectionStatus}
            />
          </div>
        </div>
      </div>
    </div>
  );
};

export default ReadingRoom;

// Continue with remaining page components...

// SERVER/PACKAGE.JSON
{
  "name": "soulseer-server",
  "version": "1.0.0",
  "description": "SoulSeer Backend API",
  "main": "index.js",
  "scripts": {
    "dev": "nodemon index.js",
    "start": "node index.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.7.4",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.0.3",
    "stripe": "^14.12.0",
    "validator": "^13.11.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}

// SERVER/.ENV
NODE_ENV=development
PORT=4000
MONGODB_URI=your_neon_database_connection_string
JWT_SECRET=your_jwt_secret_key_here
STRIPE_SECRET_KEY=sk_test_your_stripe_secret_key
STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret

// SERVER/INDEX.JS
require('dotenv').config();
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const mongoose = require('mongoose');

// Routes
const authRoutes = require('./routes/auth');
const userRoutes = require('./routes/users');
const sessionRoutes = require('./routes/sessions');
const stripeRoutes = require('./routes/stripe');
const messageRoutes = require('./routes/messages');
const adminRoutes = require('./routes/admin');

// Middleware
const authMiddleware = require('./middleware/auth');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: process.env.CLIENT_URL || "http://localhost:3000",
    methods: ["GET", "POST"]
  }
});

// Database connection
mongoose.connect(process.env.MONGODB_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
.then(() => console.log('Connected to MongoDB'))
.catch(err => console.error('MongoDB connection error:', err));

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/sessions', sessionRoutes);
app.use('/api/stripe', stripeRoutes);
app.use('/api/messages', messageRoutes);
app.use('/api/admin', adminRoutes);

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

// WebRTC Signaling
io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  socket.on('join-session', (sessionId) => {
    socket.join(sessionId);
    console.log(`User ${socket.id} joined session ${sessionId}`);
    
    // Notify others in the session
    socket.to(sessionId).emit('user-joined', socket.id);
  });

  socket.on('offer', ({ sessionId, offer }) => {
    socket.to(sessionId).emit('offer', offer);
  });

  socket.on('answer', ({ sessionId, answer }) => {
    socket.to(sessionId).emit('answer', answer);
  });

  socket.on('ice-candidate', ({ sessionId, candidate }) => {
    socket.to(sessionId).emit('ice-candidate', candidate);
  });

  socket.on('end-session', (sessionId) => {
    socket.to(sessionId).emit('session-ended');
    socket.leave(sessionId);
  });

  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ message: 'Something went wrong!' });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ message: 'Route not found' });
});

const PORT = process.env.PORT || 4000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

module.exports = { app, io };

// SERVER/CONFIG/DATABASE.JS
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });

    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error('Database connection error:', error);
    process.exit(1);
  }
};

module.exports = connectDB;

// SERVER/MODELS/USER.JS
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  role: {
    type: String,
    enum: ['client', 'reader', 'admin'],
    default: 'client'
  },
  profile: {
    name: String,
    avatar: String,
    bio: String,
    specialties: [String],
    rating: {
      type: Number,
      default: 0
    },
    totalReviews: {
      type: Number,
      default: 0
    }
  },
  readerSettings: {
    isOnline: {
      type: Boolean,
      default: false
    },
    rates: {
      video: {
        type: Number,
        default: 3.99
      },
      audio: {
        type: Number,
        default: 2.99
      },
      chat: {
        type: Number,
        default: 1.99
      }
    },
    availability: [{
      day: String,
      startTime: String,
      endTime: String
    }]
  },
  balance: {
    type: Number,
    default: 0
  },
  earnings: {
    total: {
      type: Number,
      default: 0
    },
    pending: {
      type: Number,
      default: 0
    },
    paid: {
      type: Number,
      default: 0
    }
  },
  stripeCustomerId: String,
  stripeAccountId: String,
  isVerified: {
    type: Boolean,
    default: false
  },
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Compare password method
userSchema.methods.comparePassword = async function(candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

// SERVER/MODELS/SESSION.JS
const mongoose = require('mongoose');

const sessionSchema = new mongoose.Schema({
  sessionId: {
    type: String,
    required: true,
    unique: true
  },
  clientId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  readerId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  sessionType: {
    type: String,
    enum: ['video', 'audio', 'chat'],
    required: true
  },
  status: {
    type: String,
    enum: ['pending', 'active', 'ended', 'cancelled'],
    default: 'pending'
  },
  startTime: Date,
  endTime: Date,
  duration: {
    type: Number,
    default: 0
  },
  rate: {
    type: Number,
    required: true
  },
  totalCost: {
    type: Number,
    default: 0
  },
  platformFee: {
    type: Number,
    default: 0
  },
  readerEarnings: {
    type: Number,
    default: 0
  },
  rating: {
    type: Number,
    min: 1,
    max: 5
  },
  review: String,
  notes: String
}, {
  timestamps: true
});

module.exports = mongoose.model('Session', sessionSchema);

// SERVER/MODELS/TRANSACTION.JS
const mongoose = require('mongoose');

const transactionSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  sessionId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Session'
  },
  type: {
    type: String,
    enum: ['charge', 'refund', 'payout', 'deposit'],
    required: true
  },
  amount: {
    type: Number,
    required: true
  },
  currency: {
    type: String,
    default: 'usd'
  },
  stripePaymentIntentId: String,
  stripeTransferId: String,
  status: {
    type: String,
    enum: ['pending', 'succeeded', 'failed', 'cancelled'],
    default: 'pending'
  },
  description: String,
  metadata: mongoose.Schema.Types.Mixed
}, {
  timestamps: true
});

module.exports = mongoose.model('Transaction', transactionSchema);

// SERVER/MODELS/MESSAGE.JS
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  senderId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  receiverId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  sessionId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Session'
  },
  content: {
    type: String,
    required: true
  },
  messageType: {
    type: String,
    enum: ['text', 'image', 'file'],
    default: 'text'
  },
  isRead: {
    type: Boolean,
    default: false
  },
  readAt: Date
}, {
  timestamps: true
});

module.exports = mongoose.model('Message', messageSchema);

// SERVER/ROUTES/AUTH.JS
const express = require('express');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const authMiddleware = require('../middleware/auth');

const router = express.Router();

// Register
router.post('/signup', async (req, res) => {
  try {
    const { email, password, role } = req.body;

    // Check if user exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'User already exists' });
    }

    // Prevent reader signup (admin only)
    if (role === 'reader') {
      return res.status(403).json({ message: 'Reader accounts must be created by admin' });
    }

    // Create user
    const user = new User({
      email,
      password,
      role: role || 'client'
    });

    await user.save();

    // Generate token
    const token = jwt.sign(
      { userId: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.status(201).json({
      token,
      user: {
        id: user._id,
        email: user.email,
        role: user.role,
        profile: user.profile
      }
    });
  } catch (error) {
    console.error('Signup error:', error);
    res.status(500).json({ message: 'Server error during registration' });
  }
});

// Login
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    // Find user
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    // Check password
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    // Check if account is active
    if (!user.isActive) {
      return res.status(403).json({ message: 'Account has been deactivated' });
    }

    // Generate token
    const token = jwt.sign(
      { userId: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({
      token,
      user: {
        id: user._id,
        email: user.email,
        role: user.role,
        profile: user.profile,
        balance: user.balance,
        earnings: user.earnings
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'Server error during login' });
  }
});

// Get current user
router.get('/me', authMiddleware, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId).select('-password');
    res.json({ user });
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router;

// SERVER/ROUTES/SESSIONS.JS
const express = require('express');
const { v4: uuidv4 } = require('uuid');
const Session = require('../models/Session');
const User = require('../models/User');
const Transaction = require('../models/Transaction');
const authMiddleware = require('../middleware/auth');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

const router = express.Router();

// Request a session
router.post('/request', authMiddleware, async (req, res) => {
  try {
    const { readerId, sessionType } = req.body;
    const clientId = req.user.userId;

    // Validate reader
    const reader = await User.findById(readerId);
    if (!reader || reader.role !== 'reader' || !reader.readerSettings.isOnline) {
      return res.status(400).json({ message: 'Reader not available' });
    }

    // Get rate
    const rate = reader.readerSettings.rates[sessionType];
    if (!rate) {
      return res.status(400).json({ message: 'Invalid session type' });
    }

    // Check client balance
    const client = await User.findById(clientId);
    if (client.balance < rate) {
      return res.status(400).json({ message: 'Insufficient balance' });
    }

    // Create session
    const session = new Session({
      sessionId: uuidv4(),
      clientId,
      readerId,
      sessionType,
      rate,
      status: 'pending'
    });

    await session.save();

    // TODO: Notify reader via socket.io
    
    res.json({
      sessionId: session.sessionId,
      message: 'Session request sent to reader'
    });
  } catch (error) {
    console.error('Session request error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Accept session (reader)
router.post('/:sessionId/accept', authMiddleware, async (req, res) => {
  try {
    const { sessionId } = req.params;
    const readerId = req.user.userId;

    const session = await Session.findOne({ sessionId, readerId });
    if (!session) {
      return res.status(404).json({ message: 'Session not found' });
    }

    if (session.status !== 'pending') {
      return res.status(400).json({ message: 'Session already accepted or ended' });
    }

    session.status = 'active';
    session.startTime = new Date();
    await session.save();

    // TODO: Notify client via socket.io

    res.json({ message: 'Session accepted', session });
  } catch (error) {
    console.error('Accept session error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Charge for session time
router.post('/charge', authMiddleware, async (req, res) => {
  try {
    const { sessionId, amount } = req.body;
    const clientId = req.user.userId;

    const session = await Session.findOne({ sessionId, clientId });
    if (!session) {
      return res.status(404).json({ message: 'Session not found' });
    }

    const client = await User.findById(clientId);
    
    // Check balance
    if (client.balance < (amount / 100)) {
      await Session.findOneAndUpdate(
        { sessionId },
        { status: 'ended', endTime: new Date() }
      );
      return res.status(400).json({ message: 'Insufficient balance' });
    }

    // Deduct from client balance
    const chargeAmount = amount / 100;
    client.balance -= chargeAmount;
    await client.save();

    // Add to reader earnings
    const platformFee = chargeAmount * 0.3;
    const readerEarnings = chargeAmount * 0.7;
    
    const reader = await User.findById(session.readerId);
    reader.earnings.pending += readerEarnings;
    await reader.save();

    // Record transaction
    const transaction = new Transaction({
      userId: clientId,
      sessionId: session._id,
      type: 'charge',
      amount: chargeAmount,
      status: 'succeeded',
      description: `Session charge - ${session.sessionType}`
    });
    await transaction.save();

    // Update session totals
    session.totalCost += chargeAmount;
    session.platformFee += platformFee;
    session.readerEarnings += readerEarnings;
    await session.save();

    res.json({
      balance: client.balance,
      charged: chargeAmount
    });
  } catch (error) {
    console.error('Charge error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// End session
router.post('/:sessionId/end', authMiddleware, async (req, res) => {
  try {
    const { sessionId } = req.params;
    const userId = req.user.userId;

    const session = await Session.findOne({ sessionId });
    if (!session) {
      return res.status(404).json({ message: 'Session not found' });
    }

    // Check if user is part of session
    const isParticipant = session.clientId.toString() === userId || 
                         session.readerId.toString() === userId;
    
    if (!isParticipant) {
      return res.status(403).json({ message: 'Not authorized' });
    }

    if (session.status === 'ended') {
      return res.status(400).json({ message: 'Session already ended' });
    }

    // End session
    session.status = 'ended';
    session.endTime = new Date();
    
    if (session.startTime) {
      session.duration = Math.floor((session.endTime - session.startTime) / 1000);
    }

    await session.save();

    // TODO: Notify other participant via socket.io

    res.json({ message: 'Session ended', session });
  } catch (error) {
    console.error('End session error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Get session history
router.get('/history', authMiddleware, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { page = 1, limit = 10 } = req.query;

    const query = {
      $or: [
        { clientId: userId },
        { readerId: userId }
      ]
    };

    const sessions = await Session.find(query)
      .populate('clientId', 'email profile')
      .populate('readerId', 'email profile')
      .sort({ createdAt: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit);

    const total = await Session.countDocuments(query);

    res.json({
      sessions,
      totalPages: Math.ceil(total / limit),
      currentPage: page
    });
  } catch (error) {
    console.error('Session history error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router;

// SERVER/ROUTES/STRIPE.JS
const express = require('express');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const User = require('../models/User');
const Transaction = require('../models/Transaction');
const authMiddleware = require('../middleware/auth');

const router = express.Router();

// Create payment intent for balance top-up
router.post('/create-payment-intent', authMiddleware, async (req, res) => {
  try {
    const { amount } = req.body; // Amount in cents
    const userId = req.user.userId;

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    let customerId = user.stripeCustomerId;

    // Create Stripe customer if doesn't exist
    if (!customerId) {
      const customer = await stripe.customers.create({
        email: user.email,
        metadata: {
          userId: userId
        }
      });
      
      customerId = customer.id;
      user.stripeCustomerId = customerId;
      await user.save();
    }

    // Create payment intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount,
      currency: 'usd',
      customer: customerId,
      metadata: {
        userId: userId,
        type: 'balance_topup'
      }
    });

    res.json({
      clientSecret: paymentIntent.client_secret
    });
  } catch (error) {
    console.error('Payment intent error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Handle successful payment
router.post('/payment-success', authMiddleware, async (req, res) => {
  try {
    const { paymentIntentId } = req.body;
    const userId = req.user.userId;

    // Retrieve payment intent from Stripe
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    
    if (paymentIntent.status === 'succeeded') {
      const amount = paymentIntent.amount / 100; // Convert from cents
      
      // Add to user balance
      const user = await User.findById(userId);
      user.balance += amount;
      await user.save();

      // Record transaction
      const transaction = new Transaction({
        userId,
        type: 'deposit',
        amount,
        stripePaymentIntentId: paymentIntentId,
        status: 'succeeded',
        description: 'Account balance top-up'
      });
      await transaction.save();

      res.json({
        success: true,
        balance: user.balance
      });
    } else {
      res.status(400).json({ message: 'Payment not completed' });
    }
  } catch (error) {
    console.error('Payment success error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Create Stripe Connect account for reader
router.post('/create-connect-account', authMiddleware, async (req, res) => {
  try {
    const userId = req.user.userId;
    const user = await User.findById(userId);

    if (user.role !== 'reader') {
      return res.status(403).json({ message: 'Only readers can create connect accounts' });
    }

    const account = await stripe.accounts.create({
      type: 'express',
      capabilities: {
        card_payments: { requested: true },
        transfers: { requested: true },
      },
      business_type: 'individual',
      metadata: {
        userId: userId
      }
    });

    // Save account ID
    user.stripeAccountId = account.id;
    await user.save();

    // Create account link for onboarding
    const accountLink = await stripe.accountLinks.create({
      account: account.id,
      refresh_url: `${process.env.CLIENT_URL}/dashboard?refresh=true`,
      return_url: `${process.env.CLIENT_URL}/dashboard?success=true`,
      type: 'account_onboarding',
    });

    res.json({
      accountId: account.id,
      onboardingUrl: accountLink.url
    });
  } catch (error) {
    console.error('Connect account error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Process daily payouts
router.post('/process-payouts', async (req, res) => {
  try {
    // This should be called by a cron job, add authentication check
    const readers = await User.find({
      role: 'reader',
      'earnings.pending': { $gte: 15 }, // Minimum $15 for payout
      stripeAccountId: { $exists: true }
    });

    const payoutResults = [];

    for (const reader of readers) {
      try {
        const payoutAmount = Math.floor(reader.earnings.pending * 100); // Convert to cents

        const transfer = await stripe.transfers.create({
          amount: payoutAmount,
          currency: 'usd',
          destination: reader.stripeAccountId,
          metadata: {
            readerId: reader._id.toString(),
            type: 'daily_payout'
          }
        });

        // Update reader earnings
        reader.earnings.paid += reader.earnings.pending;
        reader.earnings.total += reader.earnings.pending;
        reader.earnings.pending = 0;
        await reader.save();

        // Record transaction
        const transaction = new Transaction({
          userId: reader._id,
          type: 'payout',
          amount: payoutAmount / 100,
          stripeTransferId: transfer.id,
          status: 'succeeded',
          description: 'Daily payout'
        });
        await transaction.save();

        payoutResults.push({
          readerId: reader._id,
          amount: payoutAmount / 100,
          status: 'success'
        });
      } catch (error) {
        console.error(`Payout failed for reader ${reader._id}:`, error);
        payoutResults.push({
          readerId: reader._id,
          status: 'failed',
          error: error.message
        });
      }
    }

    res.json({
      processed: payoutResults.length,
      results: payoutResults
    });
  } catch (error) {
    console.error('Process payouts error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router;

// SERVER/MIDDLEWARE/AUTH.JS
const jwt = require('jsonwebtoken');
const User = require('../models/User');

const authMiddleware = async (req, res, next) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ message: 'No token, authorization denied' });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    const user = await User.findById(decoded.userId);
    if (!user || !user.isActive) {
      return res.status(401).json({ message: 'Token is not valid' });
    }

    req.user = {
      userId: decoded.userId,
      role: decoded.role
    };
    
    next();
  } catch (error) {
    console.error('Auth middleware error:', error);
    res.status(401).json({ message: 'Token is not valid' });
  }
};

// Role-based middleware
const requireRole = (roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ message: 'Access denied' });
    }
    next();
  };
};

module.exports = authMiddleware;
module.exports.requireRole = requireRole;
